<!DOCTYPE html>
<html>
	<head>
		<script data-main="app" src="lib/require.js"></script>



	<!--  -->



		<script id="shader-fs-color" type="x-shader/x-fragment">

			precision mediump float;

			varying vec4 vColor;

			void main(void) {

				gl_FragColor = vColor;
			}
		</script>

		<script id="shader-vs-color" type="x-shader/x-vertex">

			attribute vec3 aVertexPosition;
			attribute vec3 aVertexColor;

			varying vec4 vColor;

			uniform mat4 uMVMatrix;
			uniform mat4 uPMatrix;

			void main(void) {

				vColor = vec4(aVertexColor,1.0);

				gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
			}
		</script>



	<!--  -->



		<script id="shader-fs-light" type="x-shader/x-fragment">

			precision mediump float;

			varying vec4 vColor;

			varying vec3 normalInterp;
			varying vec3 vertPos;


			const vec3 lightPos = vec3(0.0,0.0,0.0);
			const vec3 specColor = vec3(1.0, 1.0, 1.0);

			void main(void) {

				vec3 normal = normalize(normalInterp);
				vec3 lightDir = normalize(lightPos - vertPos);

				float lambertian = max(dot(lightDir,normal), 0.0);
				float specular = 0.0;

				if (lambertian > 0.0) {

					vec3 reflectDir = reflect(-lightDir, normal);
					vec3 viewDir = normalize(-vertPos);

					float specAngle = max(dot(reflectDir, viewDir), 0.0);
					if (specAngle > 0)
						specular = pow(specAngle, 4.0);
				}

				gl_FragColor = vec4( vColor.xyz * 0.2 + lambertian * vColor.xyz + specular * specColor, 1.0);
			}
		</script>

		<script id="shader-vs-light" type="x-shader/x-vertex">

			attribute vec3 aVertexPosition, aVertexColor, aVertexNormal;

			uniform mat4 uMVMatrix;
			uniform mat4 uPMatrix;

			varying vec4 vColor;

			varying vec3 normalInterp, vertPos;

			void main(void) {

				vec4 vertPos4 = uMVMatrix * vec4(aVertexPosition, 1.0);
				vertPos = vec3(vertPos4) / vertPos4.w;
				normalInterp = vec3( uMVMatrix * vec4(aVertexNormal, 0.0) );

				//

				gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);

				vColor = vec4(aVertexColor, 1);
			}
		</script>



	<!--  -->



		<script id="shader-fs-bcenter" type="x-shader/x-fragment">

			precision mediump float;

			varying vec4 vColor;
			varying vec3 vBCenter;

			void main(void) {

				if (any(lessThan(vBCenter, vec3(0.02))))
					gl_FragColor = vec4(1);
				else
					gl_FragColor = vColor;
			}
		</script>

		<script id="shader-vs-bcenter" type="x-shader/x-vertex">

			attribute vec3 aVertexPosition;
			attribute vec3 aVertexColor;
			attribute vec3 aVertexBCenter;

			varying vec4 vColor;
			varying vec3 vBCenter;

			uniform mat4 uMVMatrix;
			uniform mat4 uPMatrix;

			void main(void) {

				vColor = vec4(aVertexColor,1.0);
				vBCenter = aVertexBCenter;

				gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
			}
		</script>



	<!--  -->



		<script id="shader-fs-experimental" type="x-shader/x-fragment">

			precision mediump float;

			varying vec4 vColor;
			varying vec3 vBCenter;

			varying vec3 vNormalInterp;
			varying vec3 vVertPos;


			const vec3 lightPos = vec3(0.0,0.0,0.0);
			const vec3 specColor = vec3(1.0, 1.0, 1.0);

			void main(void) {

				//
				//
				// wireframe

				if (gl_FrontFacing)
				{
					if (all(greaterThan(vBCenter, vec3(0.03))) &&
						any(lessThan(vBCenter, vec3(0.06))))
					{
						gl_FragColor = vColor;
						return;
					}
				}
				else
				{
					if (any(lessThan(vBCenter, vec3(0.06))))
					{
						gl_FragColor = vec4(1);
						return;
					}
				}

				// /wireframe
				//
				//

				// lines only for the backface
				if (!gl_FrontFacing)
					discard;

				// lighting
				vec3 normal = normalize(vNormalInterp);
				vec3 lightDir = normalize(lightPos - vVertPos);

				float lambertian = max(dot(lightDir,normal), 0.0);
				float specular = 0.0;

				// lighting specular
				if (lambertian > 0.0)
				{
					vec3 reflectDir = reflect(-lightDir, normal);
					vec3 viewDir = normalize(-vVertPos);

					float specAngle = max(dot(reflectDir, viewDir), 0.0);
					specular = pow(specAngle, 8.0);
				}

				// lighting output
				gl_FragColor = vec4(vColor.xyz*0.2 + lambertian*vColor.xyz + specular*specColor, 1.0);
			}
		</script>

		<script id="shader-vs-experimental" type="x-shader/x-vertex">

			attribute vec3 aVertexPosition, aVertexColor, aVertexNormal, aVertexBCenter;

			uniform mat4 uMVMatrix;
			uniform mat4 uPMatrix;

			varying vec4 vColor;
			varying vec3 vBCenter;

			varying vec3 vNormalInterp, vVertPos;

			const float k_range = 10.0;
			const float k_range_width = 3.0;

			void main(void) {

				vec4 vertPos4 = uMVMatrix * vec4(aVertexPosition, 1.0);
				vVertPos = vec3(vertPos4) / vertPos4.w;
				vNormalInterp = vec3( uMVMatrix * vec4(aVertexNormal, 0.0) );

				//

				gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);

				vColor = vec4(aVertexColor, 1);
				vBCenter = aVertexBCenter;
			}
		</script>



	<!--  -->



<style>
/*	.my_cells {*/
	#my_table td {
		background-color: #88f;
		text-align: center;
		border: 2px solid black;
	}
</style>

	</head>


	<body>

		<table border='1'>
			<tr>

				<td>
					<canvas id="main-canvas" style="border: none;" width="800" height="600">
					</canvas>
				</td>


				<td>

					<table id="my_table" cellspacing=2 cellpadding=2 >

						<tr><th colspan="3">Move</th></tr>
						<tr><th></th><td>Z/W</td><th></th></tr>
						<tr><td>Q/A</td><td>S</td><td>D</td></tr>

						<tr><th colspan="3">Look</th></tr>
						<tr><th></th><td>Up</td><th></th></tr>
						<tr><td>Left</td><td>Down</td><td>Right</td></tr>
						<tr><td colspan="3">&lt;= or click to use<br/>
						your mouse cursor</td></tr>

					</table>

					<table>

						<tr><th colspan="3">Interface</th></tr>

						<tr><th colspan="3">
							<button id="gui_reset">Reset Generation</button>
						</th></tr>

						<tr>
							<th colspan="1"><p>Octaves</p></th>
							<th colspan="2">
								<input
									id="range_octaves" type="range"
									min="1" max="5" value="1" step="1"/>
							</th>
						</tr>

						<tr>
							<th colspan="1"><p>Frequency</p></th>
							<th colspan="2">
								<input
									id="range_frequency" type="range"
									min="25" max="200" value="100" step="5"/>
							</th>
						</tr>

						<tr>
							<th colspan="1">
								<input
									id="check_tetra" type="checkbox" />
							</th>
							<th colspan="2"><p>Marching Tetrahedron</p></th>
						</tr>
					</table>

				</td>

			</tr>

<!-- 
			<tr>
				<td>
					<textarea rows="20" cols="100">
					test
					test
					test
					test
					</textarea>
				</td>
			</tr>
 -->

		</table>

	</body>

</html>
