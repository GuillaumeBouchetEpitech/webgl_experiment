<!DOCTYPE html>
<html>
	<head>
		<script data-main="app" src="lib/require.js"></script>



	<!--  -->



		<script id="shader-fs-color" type="x-shader/x-fragment">

			precision mediump float;

			varying vec4 vColor;

			void main(void) {

				gl_FragColor = vColor;
			}
		</script>

		<script id="shader-vs-color" type="x-shader/x-vertex">

			attribute vec3 aVertexPosition;
			attribute vec3 aVertexColor;

			varying vec4 vColor;

			uniform mat4 uMVMatrix;
			uniform mat4 uPMatrix;

			void main(void) {

				vColor = vec4(aVertexColor,1.0);

				gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
			}
		</script>



	<!--  -->



		<script id="shader-fs-light" type="x-shader/x-fragment">

			precision mediump float;

			varying vec4 vColor;

			varying vec3 normalInterp;
			varying vec3 vertPos;


			const vec3 lightPos = vec3(0.0,0.0,0.0);
			const vec3 specColor = vec3(1.0, 1.0, 1.0);

			void main(void) {

				vec3 normal = normalize(normalInterp);
				vec3 lightDir = normalize(lightPos - vertPos);

				float lambertian = max(dot(lightDir,normal), 0.0);
				float specular = 0.0;

				if (lambertian > 0.0) {

					vec3 reflectDir = reflect(-lightDir, normal);
					vec3 viewDir = normalize(-vertPos);

					float specAngle = max(dot(reflectDir, viewDir), 0.0);
					if (specAngle > 0)
						specular = pow(specAngle, 4.0);
				}

				gl_FragColor = vec4( vColor.xyz * 0.2 + lambertian * vColor.xyz + specular * specColor, 1.0);
			}
		</script>

		<script id="shader-vs-light" type="x-shader/x-vertex">

			attribute vec3 aVertexPosition, aVertexColor, aVertexNormal;

			uniform mat4 uMVMatrix;
			uniform mat4 uPMatrix;

			varying vec4 vColor;

			varying vec3 normalInterp, vertPos;

			void main(void) {

				vec4 vertPos4 = uMVMatrix * vec4(aVertexPosition, 1.0);
				vertPos = vec3(vertPos4) / vertPos4.w;
				normalInterp = vec3( uMVMatrix * vec4(aVertexNormal, 0.0) );

				//

				gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);

				vColor = vec4(aVertexColor, 1);
			}
		</script>



	<!--  -->



		<script id="shader-fs-bcenter" type="x-shader/x-fragment">

			precision mediump float;

			varying vec4 vColor;
			varying vec3 vBCenter;

			void main(void) {

				if (any(lessThan(vBCenter, vec3(0.02))))
					gl_FragColor = vec4(1);
				else
					gl_FragColor = vColor;
			}
		</script>

		<script id="shader-vs-bcenter" type="x-shader/x-vertex">

			attribute vec3 aVertexPosition;
			attribute vec3 aVertexColor;
			attribute vec3 aVertexBCenter;

			varying vec4 vColor;
			varying vec3 vBCenter;

			uniform mat4 uMVMatrix;
			uniform mat4 uPMatrix;

			void main(void) {

				vColor = vec4(aVertexColor,1.0);
				vBCenter = aVertexBCenter;

				gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
			}
		</script>



	<!--  -->



		<script id="shader-fs-experimental" type="x-shader/x-fragment">

			precision mediump float;

			uniform sampler2D uSampler;

			varying vec4 vColor;
			varying vec3 vBCenter;

			varying vec3 vNormalInterp;
			varying vec3 vVertPos;
			varying float vDistance;

			// TODO -> this is dirty
			varying vec3 vVertPos2;
			varying vec3 vNormalInterp2;

			const vec3 lightPos = vec3(0.0,0.0,0.0);
			const vec3 specColor = vec3(1.0, 1.0, 1.0);

			void main(void) {


				//
				//
				// wireframe

				if (gl_FrontFacing)
				{

					// if (vDistance < 20.5)
					if (vDistance > 20.0 && vDistance < 21.0)
					{

						if (all(greaterThan(vBCenter, vec3(0.03))) &&
							any(lessThan(vBCenter, vec3(0.08))))
						{
							gl_FragColor = vColor;
							return;
						}
							
					}

				}
				else
				{
					if (any(lessThan(vBCenter, vec3(0.06))))
					{
						gl_FragColor = vec4(1);
						return;
					}
				}

				// /wireframe
				//
				//

				// lines only for the backface
				if (!gl_FrontFacing)
					discard;

				// lighting
				vec3 normal = normalize(vNormalInterp);
				vec3 lightDir = normalize(lightPos - vVertPos);

				// TODO -> this is dirty
				vec3 test = vec3(
					 vVertPos2.x - floor(vVertPos2.x)
					,vVertPos2.y - floor(vVertPos2.y)
					,vVertPos2.z - floor(vVertPos2.z)
				);

				vec3 tmp_color = vColor.xyz;
				vec3 tmp_normal = vNormalInterp.xyz;

				{
					// TODO -> this is dirty
			        vec3 normal2 = normalize( vNormalInterp2.xyz );
			        vec3 blend_weights = abs( normal2 );
			        blend_weights = ( blend_weights - 0.2 ) * 7.;  
			        blend_weights = max( blend_weights, 0. );
			        blend_weights /= ( blend_weights.x + blend_weights.y + blend_weights.z );

			        vec2 coord1 = test.yz * 0.5 + 0.5;
			        vec2 coord2 = test.xz * 0.5 + 0.5;
			        vec2 coord3 = test.xy * 0.5;

			        // dirt on the ceilling instead of grass
			        if (vNormalInterp2.z < 0.0)
				        coord3 = vec2(test.x * 0.5, test.y * 0.5 + 0.5);

			        vec3 bump1 = texture2D( uSampler, coord1 ).rgb;
			        vec3 bump2 = texture2D( uSampler, coord2 ).rgb;
			        vec3 bump3 = texture2D( uSampler, coord3 ).rgb;

			        vec3 blended_bump = bump1 * blend_weights.xxx +
			                            bump2 * blend_weights.yyy +
			                            bump3 * blend_weights.zzz;

					tmp_color = blended_bump;
				}

				float lambertian = max(dot(lightDir,tmp_normal), 0.0);
				float specular = 0.0;

				// lighting specular
				if (lambertian > 0.0)
				{
					vec3 reflectDir = reflect(-lightDir, normal);
					vec3 viewDir = normalize(-vVertPos);

					float specAngle = max(dot(reflectDir, viewDir), 0.0);
					specular = pow(specAngle, 8.0);
				}

				// lighting output
				gl_FragColor = vec4(tmp_color.xyz*0.2 + lambertian*tmp_color.xyz + specular*specColor, 1.0);
			}
		</script>

		<script id="shader-vs-experimental" type="x-shader/x-vertex">

			attribute vec3 aVertexPosition, aVertexColor, aVertexNormal, aVertexBCenter;

			uniform mat4 uMVMatrix;
			uniform mat4 uPMatrix;
			uniform vec3 uCameraPos;

			varying vec4 vColor;
			varying vec3 vBCenter;

			varying vec3 vNormalInterp;
			varying vec3 vVertPos;
			varying float vDistance;
			varying vec3 vVertPos2;
			varying vec3 vNormalInterp2;

			const float k_range = 10.0;
			const float k_range_width = 3.0;


			void main(void) {

				vec4 vertPos4 = uMVMatrix * vec4(aVertexPosition, 1.0);
				vNormalInterp = vec3( uMVMatrix * vec4(aVertexNormal, 0.0) );

				vVertPos = vec3(vertPos4) / vertPos4.w;
				vVertPos2 = aVertexPosition;
				vNormalInterp2 = aVertexNormal;

				//

				float tmp_dist = length( aVertexPosition - uCameraPos );

				vDistance = tmp_dist;

				if (tmp_dist < 20.0 || tmp_dist > 21.0)
				{
					vColor = vec4(aVertexColor, 1);

					gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
				}
				else
				{
					vColor = vec4(0);

					vec3 tmp_pos = (aVertexPosition + aVertexNormal);
					gl_Position = uPMatrix * uMVMatrix * vec4(tmp_pos, 1.0);
				}

				//


				// vColor = vec4(aVertexColor, 1);
				vBCenter = aVertexBCenter;
			}
		</script>



	<!--  -->



<style>
/*	.my_cells {*/
	#my_table td {
		background-color: #88f;
		text-align: center;
		border: 2px solid black;
	}
</style>

	</head>


	<body>

		<table border='1'>
			<tr>

				<td>
					<canvas id="main-canvas" style="border: none;" width="800" height="600">
					</canvas>
				</td>


				<td>

					<table id="my_table" cellspacing=2 cellpadding=2 >

						<tr><th colspan="3">Touch event:</th></tr>
						<tr><th colspan="3" id="touch_id"></th></tr>

						<tr><th colspan="3">Move</th></tr>
						<tr><th></th><td>Z/W</td><th></th></tr>
						<tr><td>Q/A</td><td>S</td><td>D</td></tr>

						<tr><th colspan="3">Look</th></tr>
						<tr><th></th><td>Up</td><th></th></tr>
						<tr><td>Left</td><td>Down</td><td>Right</td></tr>
						<tr><td colspan="3">&lt;= or click to use<br/>
						your mouse cursor</td></tr>

					</table>

					<table>

						<tr><th colspan="3">Interface</th></tr>

						<tr><th colspan="3">
							<button id="gui_reset">Reset Generation</button>
						</th></tr>

						<tr><th colspan="3">
							<button id="gui_fullscreen">Fullscreen mode</button>
						</th></tr>

						<tr>
							<th colspan="1"><p>Octaves</p></th>
							<th colspan="2">
								<input
									id="range_octaves" type="range"
									min="1" max="5" value="1" step="1"/>
							</th>
						</tr>

						<tr>
							<th colspan="1"><p>Frequency</p></th>
							<th colspan="2">
								<input
									id="range_frequency" type="range"
									min="25" max="200" value="100" step="5"/>
							</th>
						</tr>

						<tr>
							<th colspan="1">
								<input
									id="check_tetra" type="checkbox" />
							</th>
							<th colspan="2"><p>Marching Tetrahedron</p></th>
						</tr>
					</table>

				</td>

			</tr>

<!-- 
			<tr>
				<td>
					<textarea rows="20" cols="100">
					test
					test
					test
					test
					</textarea>
				</td>
			</tr>
 -->

		</table>

	</body>

</html>
